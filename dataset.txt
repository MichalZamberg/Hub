import numpy as np
from torch.utils.data import Dataset
import pandas as pd

class CellsDataset(Dataset):
    def __init__(self, cells):
        """
        Initalize the dataset.
        Cells is a list of cells with the columns: image_id, cell_id, centroid-0, centroid-1.
        """
        super().__init__()
        # Complete here the initlization of the dataset
        # HINT: Use caching for faster implementation
        if isinstance(cells, pd.DataFrame):
            self.cells = cells.to_dict(orient='records')
        else:
            self.cells = cells
        self.cache = {}
        self.cache_size = 100
        self.path = "/home/projects/aihubadm/aihub_shared/ex-cell-classification/Multiplexed_Images"
        self.cells2labels = np.load(rf"{self.path}/cells2labels/1.npz")["data"]

   
    def __len__(self):
        """
         Return the size of the dataset
        """
        return len(self.cells)

    def __getitem__(self, i):
        """
        Return a crop of all the proteins around the ith cell in the data and its cell type. The crop should be of size 60x60 pixels.
        """
        # Complete the function such that it'll return the ith cell's image, it's segmentation and its label.
        # The returned img should be a crop around the center of the ith cell.
        # The returned img should be shaped (H, W, C). where C represents the number of channels in image_path. H, W should be set to 60 pixels. such that the size of the crop will be 60x0px
        # The returned segmentation should be a crop (H, W) around the center of the ith cell. the values of the segmentation should be 1 where the cell exists and 0 otherwise.
        # Note that any cell types which is undefined (i.e. negative) should be set to 15 (15 is a new cell types we are defining here).
        if i in self.cache:
            return self.cache[i]
        
        cell = self.cells[i]
        image_id = cell['image_id']
        centroid = (int(cell['centroid-0']), int(cell['centroid-1']))
        image_path = rf"{self.path}/data/images/{image_id}.npz"
        image = np.load(image_path)["data"]
        segmentation_path = rf"{self.path}/cells/{image_id}.npz"
        segmentation = np.load(segmentation_path)["data"]
        
        
        croped_img, croped_seg = self.crop_image(image,segmentation,centroid,size_px=60)
        
        cell_id = cell['cell_id']
        cell_type = self.cells2labels[cell_id]
        if cell_type < 0:
            cell_type = 15  
        
       # Debugging print statement
        print(f"Index: {i}, Cell ID: {cell_id}, Expected Cell Type: 1, Retrieved Cell Type: {cell_type}")

        # Check the exact mapping in cells2labels
        expected_type = self.cells2labels[cell_id]
        print(f"Cell ID: {cell_id}, Mapped Cell Type in cells2labels: {expected_type}")

        
        item = {'image': croped_img, 'segmentation': croped_seg, 'cell_type': cell_type}
        if len(self.cache) < self.cache_size:
            self.cache[i] = item
        item = (croped_img, croped_seg, cell_type)
        return item
             
    def crop_image(self,image,seg,centroid,size_px=60):
        x_location, y_location = centroid
        crop = image[x_location-size_px//2:x_location+size_px//2,
        y_location-size_px//2:y_location+size_px//2, :]
        seg_crop = seg[x_location-size_px//2:x_location+size_px//2,
        y_location-size_px//2:y_location+size_px//2]
        return crop, seg_crop